<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Shubin</title>
        <link>https://898311543.github.io/post/</link>
        <description>Recent content in Posts on Shubin</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 15 Dec 2024 23:03:55 +0800</lastBuildDate><atom:link href="https://898311543.github.io/post/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>虚拟货币投资入门</title>
        <link>https://898311543.github.io/post/%E8%99%9A%E6%8B%9F%E8%B4%A7%E5%B8%81%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8/</link>
        <pubDate>Sun, 15 Dec 2024 23:03:55 +0800</pubDate>
        
        <guid>https://898311543.github.io/post/%E8%99%9A%E6%8B%9F%E8%B4%A7%E5%B8%81%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8/</guid>
        <description>&lt;h1 id=&#34;虚拟货币投资入门&#34;&gt;&lt;strong&gt;虚拟货币投资入门&lt;/strong&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;什么是比特币&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字化的黄金：全新的品类、无发行方、便于隐藏财富、账本公开、能够点对点转账&lt;/li&gt;
&lt;li&gt;巧妙的机制：利用矿工之间为了利益挖矿的内卷、顺便实现了维护网络的安全&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么是usdt&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区块链上的虚拟美元&lt;/li&gt;
&lt;li&gt;美元类似于美元的兑换券，usdt类似于美元的兑换劵&lt;/li&gt;
&lt;li&gt;类似于赌场的筹码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;币的类别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经济模型：代币分布、解锁规则、强庄 token.unlocks.app 有些币会有源源不断的筹码进行稀释&lt;/li&gt;
&lt;li&gt;投资信息：rootdata -&amp;gt;可以判断投资方是否靠谱&lt;/li&gt;
&lt;li&gt;治理代币（仅有投票权） -&amp;gt;没有用&lt;/li&gt;
&lt;li&gt;消耗代币 -&amp;gt;用这个网络就必须用这个代币 -&amp;gt;流通量会减少&lt;/li&gt;
&lt;li&gt;金铲子代币 -&amp;gt;可以通过这个金铲子代币来挖其他的币&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;了解在币圈的生态位&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;勇于拥抱新的叙事、在高歌的时候离席&lt;/li&gt;
&lt;li&gt;敢于抄底btc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同的虚拟货币&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更深入的了解btc&lt;/li&gt;
&lt;li&gt;了解eth和sol这两个标杆代币&lt;/li&gt;
&lt;li&gt;bnb、bgb等平台币（铲子类）&lt;/li&gt;
&lt;li&gt;其他山寨版（披着技术外衣骗钱）&lt;/li&gt;
&lt;li&gt;meme币（炒作热度、情绪价值）&lt;/li&gt;
&lt;li&gt;擅长读doc文档、官方推特、团队人员、侦探思维 优点缺点路线图
&lt;ul&gt;
&lt;li&gt;文档清晰&lt;/li&gt;
&lt;li&gt;疑问能够在社区快速解答&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资金管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不满仓 不梭哈&lt;/li&gt;
&lt;li&gt;不要同时被多位kol洗脑 -&amp;gt;大概率是广告&lt;/li&gt;
&lt;li&gt;不要成为别人的流动性 喊单出货&lt;/li&gt;
&lt;li&gt;博弈市场&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;币圈必备工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;看行情 tradingview&lt;/li&gt;
&lt;li&gt;看币种 coinmarketcap coingecko&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去中心化交易所&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;uniswap&lt;/li&gt;
&lt;li&gt;Raydium&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;钱包&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;欧意web3钱包&lt;/li&gt;
&lt;li&gt;phantom钱包（sol链）&lt;/li&gt;
&lt;li&gt;onekey冷钱包&lt;/li&gt;
&lt;li&gt;trezor钱包&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新闻和资讯&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;吴说&lt;/li&gt;
&lt;li&gt;区块律动&lt;/li&gt;
&lt;li&gt;cointelegraph&lt;/li&gt;
&lt;li&gt;Coin desk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交易类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现货&lt;/li&gt;
&lt;li&gt;合约（期货）
&lt;ul&gt;
&lt;li&gt;能做多做空&lt;/li&gt;
&lt;li&gt;能开杠杆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理财
&lt;ul&gt;
&lt;li&gt;无风险理财&lt;/li&gt;
&lt;li&gt;结构化产品-&amp;gt;要玩保底的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;期权&lt;/li&gt;
&lt;li&gt;跟单&lt;/li&gt;
&lt;li&gt;机器人
&lt;ul&gt;
&lt;li&gt;网格交易&lt;/li&gt;
&lt;li&gt;CTA量化策略&lt;/li&gt;
&lt;li&gt;马丁格尔工具&lt;/li&gt;
&lt;li&gt;资金费率套利工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;永续合约&#34;&gt;永续合约
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;期货合约（期货）
&lt;ul&gt;
&lt;li&gt;期：未来的时间 本周 本季 下季&lt;/li&gt;
&lt;li&gt;货物： 一手交钱 一手交货 交割&lt;/li&gt;
&lt;li&gt;约： 合同 订好时间 价格 数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241216234200632.png&#34; alt=&#39;image-20241216234200632&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;套期保值&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241216234344431.png&#34; alt=&#39;image-20241216234344431&#39; /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合同也可以被买卖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241216234442857.png&#34; alt=&#39;image-20241216234442857&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241216234504738.png&#34; alt=&#39;image-20241216234504738&#39; /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;永续合约唯一的目的就是预测资产的价格并且交易它 免去投机者频繁调仓的麻烦&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241216234745763.png&#34; alt=&#39;image-20241216234745763&#39; /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;交割合约通过到期日的实物交割 来完成期货价格和现货价格的锚定 才能让期货的价格不会偏离现货的价格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了让永续合约也不偏离现货的价格 永续合约引入了资金费率的概念 这个资金费率不是交易所收取的 而是多头和空头相互支付的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所以资金费率有正有负&lt;/li&gt;
&lt;li&gt;如果永续合约价格高于现货的价格 资金费率就会是正的 做多的人需要向做空的人 支付费率&lt;/li&gt;
&lt;li&gt;如果永续合约价格低于现货的价格 资金费率会是负的 做空的人需要向做多的人支付费率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241216235441419.png&#34; alt=&#39;image-20241216235441419&#39; /&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;资金费率套利&#34;&gt;资金费率套利
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;资金费率大多是正的 可以通过买入现货 同时一倍做空&lt;/li&gt;
&lt;li&gt;通过判断极端值来找到交易的机会&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241216235853497.png&#34; alt=&#39;image-20241216235853497&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241217001003893.png&#34; alt=&#39;image-20241217001003893&#39; /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先借币 高价卖出 再买币 把币还了&lt;/li&gt;
&lt;li&gt;常规理解 低买高卖 必须先有币才能卖 -&amp;gt;衍生理解 没有货也能卖&lt;/li&gt;
&lt;li&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241217001359709.png&#34; alt=&#39;image-20241217001359709&#39; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241217001538379.png&#34; alt=&#39;image-20241217001538379&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241217001619007.png&#34; alt=&#39;image-20241217001619007&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241217001653051.png&#34; alt=&#39;image-20241217001653051&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241217001826326.png&#34; alt=&#39;image-20241217001826326&#39; /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有的买单和所有的卖单加起来称为盘口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现价单 = maker 创造流动性 手续费更低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;市价单 = taker 吃掉了流动性 手续费更高&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241217002045683.png&#34; alt=&#39;image-20241217002045683&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241217005353766.png&#34; alt=&#39;image-20241217005353766&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20241217005435678.png&#34; alt=&#39;image-20241217005435678&#39; /&gt;
&lt;/p&gt;
&lt;h3 id=&#34;平台币&#34;&gt;平台币
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;okb 价格腰斩 -&amp;gt;没有流动性&lt;/li&gt;
&lt;li&gt;bnb -&amp;gt; 太贵了 但是很稳&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;比特币课程&#34;&gt;比特币课程
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;金钱的功能
一个媒介，一种度量衡，一个标准，一种储值方式&lt;/li&gt;
&lt;li&gt;商品货币：由实际有价值的商品制成，例如黄金
&lt;ul&gt;
&lt;li&gt;角色扮演游戏中的 &amp;ldquo;金币”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代表货币：由有价值的“东西”支持的货币，例如黄金
&lt;ul&gt;
&lt;li&gt;当美元处于“金本位”时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;法定货币：由政府“通过法定货币”建立
&lt;ul&gt;
&lt;li&gt;现在的美元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加密货币
&lt;ul&gt;
&lt;li&gt;旨在作为交换媒介的数字资产&lt;/li&gt;
&lt;li&gt;“一种被广泛接受的代币，可以兑换商品和服务”&lt;/li&gt;
&lt;li&gt;跟所有的现代货币一样&lt;/li&gt;
&lt;li&gt;他们使用现代加密技术（加密和散列），因此得名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;什么是加密货币
&lt;ul&gt;
&lt;li&gt;没有中央权威，其状态通过分布式共识维持&lt;/li&gt;
&lt;li&gt;该系统保留了加密货币单位及其所有权的概览&lt;/li&gt;
&lt;li&gt;该系统定义了是否可以创建新的加密货币单位以及如何创建&lt;/li&gt;
&lt;li&gt;加密货币单位的所有权可以完全通过加密方式证明&lt;/li&gt;
&lt;li&gt;该系统允许交易（转账），该交易只能由能够证明源货币所有权的实体进行&lt;/li&gt;
&lt;li&gt;如果同时输入两条不同的指令来更改同一加密单元的所有权，系统最多执行其中一条指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;是什么让钱变得有价值
&lt;ul&gt;
&lt;li&gt;它被广泛接受&lt;/li&gt;
&lt;li&gt;它得到稳定的政府或实体的支持&lt;/li&gt;
&lt;li&gt;它有一个合理的通货膨胀率&lt;/li&gt;
&lt;li&gt;它可以交换其他有价值的东西&lt;/li&gt;
&lt;li&gt;例如：
&lt;ul&gt;
&lt;li&gt;美元是国际金融交易中使用最广泛的货币&lt;/li&gt;
&lt;li&gt;由于委内瑞拉的危机，委内瑞拉玻利瓦尔索贝拉诺（VEB）及其前身玻利瓦尔富尔特基本上一文不值&lt;/li&gt;
&lt;li&gt;VEB 2018 年的通货膨胀率为 1,698,488%（是的，170 万%）
2020 年约为 5,000%&lt;/li&gt;
&lt;li&gt;萨尔瓦多
&lt;ul&gt;
&lt;li&gt;官方货币：美元和比特币&lt;/li&gt;
&lt;li&gt;因此，货币政策的控制力有限&lt;/li&gt;
&lt;li&gt;2021 年，他们以 4,672 美元的价格开采了 269 美元的 BTC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;是什么让数字货币有价值
&lt;ul&gt;
&lt;li&gt;这是指没有非数字等价物的货币&lt;/li&gt;
&lt;li&gt;但满足如下情况时 他就会值钱
&lt;ul&gt;
&lt;li&gt;广泛的认同&lt;/li&gt;
&lt;li&gt;实体愿意将其兑换成商品或其他货币&lt;/li&gt;
&lt;li&gt;可以换成别的东西&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;btc如何转账？
&lt;ul&gt;
&lt;li&gt;要将 x 从您自己 (S) 转移到目的地 (D)
&lt;ul&gt;
&lt;li&gt;S和D是钱包的公钥&lt;/li&gt;
&lt;li&gt;获得资金的交易的哈希值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用钱包的私钥进行签名&lt;/li&gt;
&lt;li&gt;然后将其广播到 P2P 网络&lt;/li&gt;
&lt;li&gt;交易最多需要 30 分钟才能完成
&lt;ul&gt;
&lt;li&gt;这可以防止双重支出&lt;/li&gt;
&lt;li&gt;也部分同时也是因为挖矿导致的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存池
&lt;ul&gt;
&lt;li&gt;所有尚未上链的交易都存储在公开的内存池或mempool中&lt;/li&gt;
&lt;li&gt;由“享有同等特权的矿工”网络维护&lt;/li&gt;
&lt;li&gt;每隔 10 分钟左右，所有交易都会合并到一个区块中&lt;/li&gt;
&lt;li&gt;该区块成为区块链的一部分（通过挖矿）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Mac m1 sshfs安装</title>
        <link>https://898311543.github.io/post/mac-m1-sshfs%E5%AE%89%E8%A3%85/</link>
        <pubDate>Wed, 06 Nov 2024 14:39:55 +0800</pubDate>
        
        <guid>https://898311543.github.io/post/mac-m1-sshfs%E5%AE%89%E8%A3%85/</guid>
        <description>&lt;h1 id=&#34;mac-m1-sshfs安装&#34;&gt;&lt;strong&gt;Mac m1 sshfs安装&lt;/strong&gt;
&lt;/h1&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/osxfuse/osxfuse&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;macxfuse安装包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://eengstrom.github.io/musings/install-macfuse-and-sshfs-on-macos-monterey&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MacFuse安装教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/article-7855-1.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;sshfs教程&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Golang学习记录</title>
        <link>https://898311543.github.io/post/golang_learning/</link>
        <pubDate>Thu, 17 Oct 2024 11:27:55 +0800</pubDate>
        
        <guid>https://898311543.github.io/post/golang_learning/</guid>
        <description>&lt;h1 id=&#34;golang-知识记录&#34;&gt;&lt;strong&gt;Golang 知识记录&lt;/strong&gt;
&lt;/h1&gt;&lt;h2 id=&#34;例子&#34;&gt;例子
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;写响应头长度&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;		fmt.Println(&amp;#34;abnormalFileServer: zeroLength&amp;#34;)
		w.Header().Set(&amp;#34;Content-Length&amp;#34;, &amp;#34;0&amp;#34;)
		w.Write([]byte(&amp;#34;This is the actual response body&amp;#34;))
		return
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;写状态码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;		fmt.Println(&amp;#34;abnormalFileServer: 404&amp;#34;)
		http.Error(w, &amp;#34;abnormalFileServer&amp;#34;, http.StatusNotFound)
		return
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;不同访问次数的访问结果不同（第一次访问成功，其他访问失败）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;		query := r.URL.Query()
		val := query.Get(&amp;#34;command&amp;#34;)
		switch  val {
			case &amp;#34;clear&amp;#34;:
				accessCount = 0
				return
		}
		if accessCount &amp;gt; 0 {
			
			http.Error(w, &amp;#34;abnormalFileServer&amp;#34;, http.StatusInternalServerError)
			fmt.Printf(&amp;#34;onlyFirstSuccess.mp4 : %d fails\n&amp;#34;,accessCount)
			accessCount ++
			return
		}
		http.ServeFile(w, r, &amp;#34;file_folder/1MB.mp4&amp;#34;)
		fmt.Printf(&amp;#34;onlyFirstSuccess.mp4 : %d success\n&amp;#34;,accessCount)
		accessCount ++
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;删除请求header中的特定参数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;			r.Header.Del(&amp;#34;Range&amp;#34;)             // 删除参数
			http.ServeFile(w, r, &amp;#34;file_folder/1022KB.mp4&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;golang-server-基本用法&#34;&gt;golang server 基本用法
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
    &amp;#34;fmt&amp;#34;
    &amp;#34;net/http&amp;#34;
)
// handler 函数有两个参数，`http.ResponseWriter` 和 `http.Request`。 response writer 被用于写入 HTTP 响应数据，这里我们简单的返回 “hello\n”。
func hello(w http.ResponseWriter, req *http.Request) {

    fmt.Fprintf(w, &amp;#34;hello\n&amp;#34;)
}
// 这个 handler 稍微复杂一点， 我们需要读取的 HTTP 请求 header 中的所有内容，并将他们输出至 response body。
func headers(w http.ResponseWriter, req *http.Request) {

    for name, headers := range req.Header {
        for _, h := range headers {
            fmt.Fprintf(w, &amp;#34;%v: %v\n&amp;#34;, name, h)
        }
    }
}

func main() {

    http.HandleFunc(&amp;#34;/hello&amp;#34;, hello)
    http.HandleFunc(&amp;#34;/headers&amp;#34;, headers)

    http.ListenAndServe(&amp;#34;:8090&amp;#34;, nil)
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关于路径&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http.HandleFunc(&amp;quot;/globFiles/&amp;quot;, globFiles) 路径最后携带/ 能够通配/globFiles开头的所有路径&lt;/li&gt;
&lt;li&gt;如果不携带只能精确匹配这个指定的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读取GET的参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取query&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;q := r.URL.Query()
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读取参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;id := query[&amp;quot;id&amp;quot;][0] &lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;id := query.Get(&amp;quot;id&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map遍历&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for key, value := range req.URL.Query() {
  fmt.Fprintf(w, &amp;#34;%v: %v\n&amp;#34;, key, value)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;类型的参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;req.ParseForm()
username := request.Form.Get(&amp;#34;username&amp;#34;)
password := request.Form.Get(&amp;#34;password&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;curl命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -X POST https://reqbin.com/echo/post/form
   -H &amp;#34;Content-Type: application/x-www-form-urlencoded&amp;#34; 
   -d &amp;#34;param1=value1&amp;amp;param2=value2&amp;#34; 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取&lt;code&gt;application/json &lt;/code&gt;类型的参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func  json_decode(w http.ResponseWriter, req *http.Request) {
	decoder := json.NewDecoder(req.Body)
	var v map[string]interface{}
	err := decoder.Decode(&amp;amp;v)
	if err != nil {
		panic(err)
	}
	for key, value := range v {
		switch value := value.(type) {
		case string:
			fmt.Printf(&amp;#34;Key: %s, Value: %s, Type: string\n&amp;#34;, key, value)
		case int:
			fmt.Printf(&amp;#34;Key: %s, Value: %d, Type: int\n&amp;#34;, key, value)
		case bool:
			fmt.Printf(&amp;#34;Key: %s, Value: %t, Type: bool\n&amp;#34;, key, value)
		case float64:
			fmt.Printf(&amp;#34;Key: %s, Value: %f, Type: float64\n&amp;#34;, key, value)
		case []string:
			fmt.Printf(&amp;#34;Key: %s, Value: %v, Type: []string\n&amp;#34;, key, value)
		default:
			fmt.Printf(&amp;#34;Key: %s, Value: %v, Type: unknown\n&amp;#34;, key, value)
		}
	}
	fmt.Fprintf(w,&amp;#34;{\&amp;#34;code\&amp;#34;:0}&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;context&#34;&gt;Context
&lt;/h3&gt;&lt;p&gt;平时在 Go 工程中开发中，几乎所有服务端（例如：HTTP Server）的默认实现，都在处理请求时新起 goroutine 进行处理。&lt;/p&gt;
&lt;p&gt;但一开始存在一个问题，那就是当一个请求被取消或超时时，所有在该请求上工作的 goroutines 应该迅速退出，以便系统可以回收他们正在使用的任何资源。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
    &amp;#34;fmt&amp;#34;
    &amp;#34;net/http&amp;#34;
    &amp;#34;time&amp;#34;
)

func hello(w http.ResponseWriter, req *http.Request) {

    ctx := req.Context()
    fmt.Println(&amp;#34;server: hello handler started&amp;#34;)
    defer fmt.Println(&amp;#34;server: hello handler ended&amp;#34;)

    select {
    case &amp;lt;-time.After(10 * time.Second):
        fmt.Fprintf(w, &amp;#34;hello\n&amp;#34;)
    case &amp;lt;-ctx.Done():

        err := ctx.Err()
        fmt.Println(&amp;#34;server:&amp;#34;, err)
        internalError := http.StatusInternalServerError
        http.Error(w, err.Error(), internalError)
    }
}

func main() {

    http.HandleFunc(&amp;#34;/hello&amp;#34;, hello)
    http.ListenAndServe(&amp;#34;:8090&amp;#34;, nil)
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;客户端主动断开后，会进入ctx.Done()分支&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>ffmpeg中级开发</title>
        <link>https://898311543.github.io/post/ffmpeg_medium/</link>
        <pubDate>Thu, 17 Oct 2024 01:02:59 +0800</pubDate>
        
        <guid>https://898311543.github.io/post/ffmpeg_medium/</guid>
        <description>&lt;h1 id=&#34;ffmpeg中级开发&#34;&gt;ffmpeg中级开发
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;H264解码&lt;/li&gt;
&lt;li&gt;H264编码&lt;/li&gt;
&lt;li&gt;AAC编码&lt;/li&gt;
&lt;li&gt;AAC解码&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常见结构体&#34;&gt;常见结构体
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;libavcodec/avcodec.h //头文件 编解码
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;AVCodec 编码器结构体
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;avcodec_alloc_context3()&lt;/code&gt; &lt;code&gt;avcodec_free_context()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AVCodecContext编解码器上下文 串联不同的函数之间的上下文&lt;/li&gt;
&lt;li&gt;AVFrame 解码后的帧
&lt;ul&gt;
&lt;li&gt;结构体的分配与释放：&lt;code&gt;av_frame_alloc() av_frame_free()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解码步骤&#34;&gt;解码步骤
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查找解码器（&lt;code&gt;avcodec_find_decoder&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开解码器（&lt;code&gt;avcodec_open2&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解码（&lt;code&gt;avcodec_decode_video2&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;libavutil/log.h&amp;gt;
#include &amp;lt;libavutil/opt.h&amp;gt;
#include &amp;lt;libavformat/avformat.h&amp;gt;
#include &amp;lt;libavcodec/avcodec.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

static void encode(AVCodecContext *ctx, AVFrame *frame, AVPacket *pkt, FILE *fp){
    int ret = -1;
    // 1.编码
    ret = avcodec_send_frame(ctx,frame);
    if(ret &amp;lt; 0){
        av_log(NULL,AV_LOG_ERROR,&amp;#34;coundn&amp;#39;t send frame %s\n&amp;#34;,av_err2str(ret));
        goto _END;
    }
    // 2.获取编码后的数据
    while (ret &amp;gt;= 0)
    {
       ret = avcodec_receive_packet(ctx,pkt);
       if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){
           return;
       } else if (ret &amp;lt; 0){
           av_log(NULL,AV_LOG_ERROR,&amp;#34;coundn&amp;#39;t receive packet %s\n&amp;#34;,av_err2str(ret));
           goto _END;
       }
        // 3.写入文件
        fwrite(pkt-&amp;gt;data,1,pkt-&amp;gt;size,fp);
        av_packet_unref(pkt);
    }
    

    return;
_END:
    if(pkt) av_packet_unref(pkt);
    if(frame) av_frame_unref(frame);
    if(ctx) avcodec_free_context(&amp;amp;ctx);
    if(fp) fclose(fp);
    return;
}

int main(int argc, char** argv){
    AVCodec *codec;
    AVCodecContext *ctx;
    AVFrame *frame = NULL;
    AVPacket *pkt = NULL;
    int ret = -1;
    av_log_set_level(AV_LOG_DEBUG);
    if(argc &amp;lt; 3){
        printf(&amp;#34;Usage: %s &amp;lt;file&amp;gt; &amp;lt;codecname&amp;gt;\n&amp;#34;, argv[0]);
        goto _ERROR;
    }
    char* dst = argv[1];
    char* codecname = argv[2];
    // 2、查找编码器
    codec = avcodec_find_encoder_by_name(codecname);
    if(!codec){
        av_log(NULL,AV_LOG_ERROR,&amp;#34;coundn&amp;#39;t find codec %s&amp;#34;,codecname);
        goto _ERROR;
    }
    // 3. 编码器上下文
    ctx = avcodec_alloc_context3(codec);
    if(!ctx) {
        av_log(NULL,AV_LOG_ERROR,&amp;#34;coundn&amp;#39;t alloc codec context&amp;#34;);
        goto _ERROR;
    }
    // 4. 设置编码器参数
    ctx-&amp;gt;width = 640;
    ctx-&amp;gt;height = 480;
    ctx-&amp;gt;bit_rate = 500000;
    ctx-&amp;gt;time_base = (AVRational){1,25};
    ctx-&amp;gt;framerate = (AVRational){25,1};
    ctx-&amp;gt;gop_size = 10;
    ctx-&amp;gt;max_b_frames = 1;
    ctx-&amp;gt;pix_fmt = AV_PIX_FMT_YUV420P;
    // h264 私有属性
    if (codec-&amp;gt;id == AV_CODEC_ID_H264){
        av_opt_set(ctx-&amp;gt;priv_data,&amp;#34;preset&amp;#34;,&amp;#34;slow&amp;#34;,0);
    }
    // 5.绑定编码器上下文和编码器
    ret = avcodec_open2(ctx,codec,NULL);
    if(ret &amp;lt; 0){
        av_log(NULL,AV_LOG_ERROR,&amp;#34;coundn&amp;#39;t open codec %s&amp;#34;,av_err2str(ret));
        goto _ERROR;
    }
    // 6. 打开文件
    FILE *fp = fopen(dst,&amp;#34;wb&amp;#34;);
    if(!fp){
        av_log(NULL,AV_LOG_ERROR,&amp;#34;coundn&amp;#39;t open file %s&amp;#34;,dst);
        goto _ERROR;
    }
    // 7. 创建AVFrame
    // 创建的只是外壳 不能真正存储文件
    frame = av_frame_alloc();
    if(!frame){
        av_log(NULL,AV_LOG_ERROR,&amp;#34;coundn&amp;#39;t alloc frame&amp;#34;);
        goto _ERROR;
    }
    frame-&amp;gt;format = ctx-&amp;gt;pix_fmt;
    frame-&amp;gt;width = ctx-&amp;gt;width;
    frame-&amp;gt;height = ctx-&amp;gt;height;
    ret = av_frame_get_buffer(frame,0);
    if(ret &amp;lt; 0){
        av_log(NULL,AV_LOG_ERROR,&amp;#34;coundn&amp;#39;t alloc frame buffer %s\n&amp;#34;,av_err2str(ret));
        goto _ERROR;
    }
    // 8. 创建AVPacket
    pkt = av_packet_alloc();
    if(!pkt){
        av_log(NULL,AV_LOG_ERROR,&amp;#34;coundn&amp;#39;t alloc packet&amp;#34;);
        goto _ERROR;
    }
    // 9. 生成视频内容
    for(int i = 0; i &amp;lt; 10; i++){
        ret = av_frame_make_writable(frame);
        if(ret &amp;lt; 0) {
            break;
        }
        for(int y = 0; y &amp;lt; frame-&amp;gt;height; y++){
            for(int x = 0; x &amp;lt; frame-&amp;gt;width; x++){
                frame-&amp;gt;data[0][y*frame-&amp;gt;linesize[0] + x] = x + y + i*3;
                frame-&amp;gt;data[1][y/2*frame-&amp;gt;linesize[1] + x/2] = 128 + y + i*2;
                frame-&amp;gt;data[2][y/2*frame-&amp;gt;linesize[2] + x/2] = 64 + x + i*5;
            }
        }
        frame-&amp;gt;pts = i;
        encode(ctx,frame,pkt,fp);
    }
    encode(ctx,NULL,pkt,fp);
    _ERROR:
        if(ctx){
            avcodec_free_context(&amp;amp;ctx);
        }
        if(frame){
            av_frame_free(&amp;amp;frame);
        }
        if(pkt){
            av_packet_free(&amp;amp;pkt);
        }
        if(fp){
            fclose(fp);
        }
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;yuv介绍&#34;&gt;YUV介绍
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;YUV是通过亮度和色彩来分别代表像素的格式，其中“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V”表示的则是色度。在实际使用中，使用的格式一般是YCbCr，其中Y是指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量。在格式上面有很多取样格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;YUV 4:4:4采样，每一个Y对应一组UV分量,一个YUV占8+8+8 = 24bits 3个字节。
YUV 4:2:2采样，每两个Y共用一组UV分量,一个YUV占8+4+4 = 16bits 2个字节。
YUV 4:2:0采样，每四个Y共用一组UV分量,一个YUV占8+2+2 = 12bits 1.5个字节。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们最常见的&lt;code&gt;YUV420P和YUV420SP&lt;/code&gt;都是基于&lt;code&gt;4:2:0&lt;/code&gt;采样的，所以如果图片的宽为&lt;code&gt;width&lt;/code&gt;，高为&lt;code&gt;heigth&lt;/code&gt;，在内存中占的空间为&lt;code&gt;width * height * 3 / 2&lt;/code&gt;，其中前&lt;code&gt;width * height&lt;/code&gt;的空间存放&lt;code&gt;Y分量&lt;/code&gt;，接着&lt;code&gt;width * height / 4&lt;/code&gt;存放&lt;code&gt;U分量&lt;/code&gt;，最后&lt;code&gt;width * height / 4&lt;/code&gt;存放&lt;code&gt;V分量&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;yuv420pyu12和yv12格式&#34;&gt;YUV420P(YU12和YV12)格式
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;YUV420P&lt;/code&gt;又叫&lt;code&gt;plane平面模式&lt;/code&gt;，&lt;code&gt;Y , U , V&lt;/code&gt;分别在不同平面，也就是有三个平面，它是&lt;code&gt;YUV标准格式4：2：0&lt;/code&gt;，主要分为：&lt;code&gt;YU12&lt;/code&gt;和&lt;code&gt;YV12&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/20181119225805899.png&#34; alt=&#39;img&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/2018111923013322.png&#34; alt=&#39;img&#39; /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;YU12格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;Android平台下&lt;/code&gt;也叫做&lt;code&gt;I420格式&lt;/code&gt;，首先是所有&lt;code&gt;Y值&lt;/code&gt;，然后是所有&lt;code&gt;U值&lt;/code&gt;，最终是所有&lt;code&gt;V值&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/2018112012345555.png&#34; alt=&#39;img&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YU12：亮度(行×列) + U(行×列/4) + V(行×列/4)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;YV12格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;YV12格式&lt;/code&gt;与&lt;code&gt;YU12&lt;/code&gt;基本相同，首先是所有&lt;code&gt;Y值&lt;/code&gt;，然后是所有&lt;code&gt;V值&lt;/code&gt;，最后是所有&lt;code&gt;U值&lt;/code&gt;。只要注意从适当的位置提取&lt;code&gt;U和V值&lt;/code&gt;，&lt;code&gt;YU12和YV12&lt;/code&gt;都可以使用相同的算法进行处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/20181120123516554.png&#34; alt=&#39;img&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YV12：亮度Y(行×列) + V(行×列/4) + U(行×列/4&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;YU12: YYYYYYYY UUVV    =&amp;gt;    YUV420P
YV12: YYYYYYYY VVUU    =&amp;gt;    YUV420P
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中比较常见的YUV420分为两种：YUV420P和YUV420SP。YUV420SP(NV21和NV12)格式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;YUV420SP&lt;/code&gt;格式的图像阵列，首先是所有&lt;code&gt;Y值&lt;/code&gt;，然后是&lt;code&gt;UV&lt;/code&gt;或者&lt;code&gt;VU&lt;/code&gt;交替存储，&lt;code&gt;NV12和NV21属于YUV420SP&lt;/code&gt;格式，是一种&lt;code&gt;two-plane模式&lt;/code&gt;，即&lt;code&gt;Y和UV分为两个plane&lt;/code&gt;，但是&lt;code&gt;UV(CbCr)&lt;/code&gt;为交错存储，而不是分为三个平面。&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/201811192258324.png&#34; alt=&#39;img&#39; /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NV21格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;android手机从摄像头采集的预览数据一般都是NV21，存储顺序是先存Y，再VU交替存储，&lt;code&gt;NV21&lt;/code&gt;存储顺序是先存&lt;code&gt;Y值&lt;/code&gt;，再&lt;code&gt;VU&lt;/code&gt;交替存储：&lt;code&gt;YYYYVUVUVU&lt;/code&gt;，以 &lt;code&gt;4 X 4&lt;/code&gt; 图片为例子，占用内存为 &lt;code&gt;4 X 4 X 3 / 2 = 24&lt;/code&gt; 个字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/20181119235116552.png&#34; alt=&#39;img&#39; /&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NV12格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NV12与NV21类似，也属于&lt;code&gt;YUV420SP&lt;/code&gt;格式，&lt;code&gt;NV12&lt;/code&gt;存储顺序是先存&lt;code&gt;Y值&lt;/code&gt;，再&lt;code&gt;UV&lt;/code&gt;交替存储：&lt;code&gt;YYYYUVUVUV&lt;/code&gt;，以 &lt;code&gt;4 X 4&lt;/code&gt; 图片为例子，占用内存为 &lt;code&gt;4 X 4 X 3 / 2 = 24&lt;/code&gt; 个字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/20181119235210475.png&#34; alt=&#39;img&#39; /&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;NV12: YYYYYYYY UVUV    =&amp;gt;YUV420SP
NV21: YYYYYYYY VUVU    =&amp;gt;YUV420SP
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://github.com/byhook/ffmpeg4android/blob/master/readme/%E5%9B%BE%E8%A7%A3YU12%E3%80%81I420%E3%80%81YV12%E3%80%81NV12%E3%80%81NV21%E3%80%81YUV420P%E3%80%81YUV420SP%E3%80%81YUV422P%E3%80%81YUV444P%E7%9A%84%E5%8C%BA%E5%88%AB.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成图片代码&#34;&gt;生成图片代码
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;libavutil/log.h&amp;gt;
#include &amp;lt;libavutil/avutil.h&amp;gt;
#include &amp;lt;libavformat/avio.h&amp;gt;
#include &amp;lt;libavformat/avformat.h&amp;gt;
#include &amp;lt;libavcodec/avcodec.h&amp;gt;


static void savePic(AVFrame *frame, char *filename){
    FILE *f = fopen(filename, &amp;#34;wb&amp;#34;);
    fprintf(f, &amp;#34;P5\n%d %d\n255\n&amp;#34;, frame-&amp;gt;width, frame-&amp;gt;height);
    // fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
    // size 每个元素的大小 nmemb 元素的个数  
    for (int i = 0; i &amp;lt; frame-&amp;gt;height; i++)
    {
        fwrite(frame-&amp;gt;data[0]+i*frame-&amp;gt;linesize[0], 1, frame-&amp;gt;width, f);
    }
    
    fclose(f);
}

static int decode(AVCodecContext *ctx, AVFrame *frame, AVPacket *pkt, char *filename){
    int ret;
    char filename_filled[1024];
    ret = avcodec_send_packet(ctx, pkt);
    if(ret &amp;lt; 0){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Error sending a packet for decoding ret = %d %d\n&amp;#34;, ret,AVERROR(EINVAL));
        return ret;
    }

    while(ret &amp;gt;= 0){
        ret = avcodec_receive_frame(ctx, frame);
        if(ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){
            return 0;
        }else if(ret &amp;lt; 0){
            av_log(NULL, AV_LOG_ERROR, &amp;#34;Error during decoding\n&amp;#34;);
            return ret;
        }
        printf(&amp;#34;frame_number = %d\n&amp;#34;, ctx-&amp;gt;frame_number);
        snprintf(filename_filled, sizeof(filename)+5, &amp;#34;%s-%d&amp;#34;, filename, ctx-&amp;gt;frame_number);
        savePic(frame, filename_filled);
        fflush(stdout);
    }
    return 0;
}


int main(int argc, char *argv[]){
    // 1、处理一些参数
    // 2、打开文件
    // 3、从多媒体文件中找到音频流
    // 4、打开目的文件的上下文
    // 5、为目的文件打开音频流
    // 6、设置输出音频参数
    // 7、写多媒体文件头
    // 8、循环读取音频流，写入目的文件
    // 9、写文件尾
    // 10、 释放资源

    char* src;
    char* dst;
    AVCodecContext *ctx;
    AVFormatContext *fmt_ctx;
    AVStream *in_stream = NULL, *out_stream = NULL;
    const static AVCodec *codec;
    AVPacket *pkt;
    AVFrame *frame;
    int index = -1;
    av_log_set_level(AV_LOG_DEBUG);
    if (argc &amp;lt; 3) {
        printf(&amp;#34;Usage: %s &amp;lt;input file&amp;gt; &amp;lt;output file&amp;gt;\n&amp;#34;, argv[0]);
        exit(1);
    }
    src = argv[1];
    dst = argv[2];
    fmt_ctx = avformat_alloc_context();
    // 第一个null 表示相关的格式 最后一个参数为选项 如果返回值为负值表示失败
    int ret = avformat_open_input(&amp;amp;fmt_ctx, src, NULL, NULL);
    if (ret &amp;lt; 0) {
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not open source file %s\n&amp;#34;, src);
        exit(1);
    }

    if ((ret = avformat_find_stream_info(fmt_ctx, NULL)) &amp;lt; 0) {
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Cannot find stream information\n&amp;#34;);
        return ret;
    }
    index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
    if(index &amp;lt; 0){
        // 第一参数可以指定为上下文
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not find %s stream in input file %s\n&amp;#34;, av_get_media_type_string(AVMEDIA_TYPE_VIDEO), src);
        goto _ERROR;
    }
    codec = avcodec_find_decoder(fmt_ctx-&amp;gt;streams[index]-&amp;gt;codecpar-&amp;gt;codec_id);
    if(codec == NULL){
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not find codec \n&amp;#34;);
        goto _ERROR;
    }
    ctx = avcodec_alloc_context3(NULL);
    if(ctx == NULL){
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not allocate codec context\n&amp;#34;);
        goto _ERROR;
    }
    // 重要 不要写avcodec_parameters_copy 否则会导致coredump
    avcodec_parameters_to_context(ctx, fmt_ctx-&amp;gt;streams[index]-&amp;gt;codecpar);
    // 将解码器和解码器上下文连接
    ret = avcodec_open2(ctx, codec, NULL);
    if(ret &amp;lt; 0){
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not open codec\n&amp;#34;);
        goto _ERROR;
    }
    frame = av_frame_alloc();
    if(frame == NULL){
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not allocate frame\n&amp;#34;);
        goto _ERROR;
    }
    pkt = av_packet_alloc();
    if(pkt == NULL){
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not allocate packet\n&amp;#34;);
        goto _ERROR;
    }
    int pkt_index = 0;
    while(av_read_frame(fmt_ctx, pkt) &amp;gt;= 0){
        if(pkt-&amp;gt;stream_index == index){
            // pkt_index ++;
            decode(ctx,frame, pkt,dst);
            if(pkt_index ++ &amp;gt; 10)
                break;
            // av_packet_unref(pkt);
        }
    }
    decode(ctx,frame, NULL,dst);

_ERROR:
    if(fmt_ctx != NULL){
        avformat_close_input(&amp;amp;fmt_ctx);
    }
    if(ctx) {
        avcodec_free_context(&amp;amp;ctx);
        ctx = NULL;
    }
    if(frame){
        av_frame_free(&amp;amp;frame);
        frame = NULL;
    }
    if(pkt){
        av_packet_free(&amp;amp;pkt);
        pkt = NULL;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;libavutil/log.h&amp;gt;
#include &amp;lt;libavutil/avutil.h&amp;gt;
#include &amp;lt;libavformat/avio.h&amp;gt;
#include &amp;lt;libavformat/avformat.h&amp;gt;
#include &amp;lt;libavcodec/avcodec.h&amp;gt;
#include &amp;lt;libswscale/swscale.h&amp;gt;

#define WORD uint16_t
#define DWORD uint32_t
#define LONG  int32_t
#pragma pack(2)
typedef struct tagBITMAPINFOHEADER {
  DWORD biSize;
  LONG  biWidth;
  LONG  biHeight;
  WORD  biPlanes;
  WORD  biBitCount;
  DWORD biCompression;
  DWORD biSizeImage;
  LONG  biXPelsPerMeter;
  LONG  biYPelsPerMeter;
  DWORD biClrUsed;
  DWORD biClrImportant;
} BITMAPINFOHEADER, *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;

typedef struct tagBITMAPFILEHEADER {
  WORD  bfType;
  DWORD bfSize;
  WORD  bfReserved1;
  WORD  bfReserved2;
  DWORD bfOffBits;
} BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;

// 1、先进行转换，将yuv420p转为rgb24
// 2、构造BITMAPINFORHEADER
// 3、构造BITMAPFILEHEADER
// 4、将数据写入文件 
// 5、释放资源
static void saveBmp(struct SwsContext *sws_ctx, AVFrame *frame, int width, int height, char *filename){
    AVFrame *frame_rgb24 = av_frame_alloc();
    FILE *f = fopen(filename, &amp;#34;wb&amp;#34;);
    int image_size = width * height * 3;
    int ret;
    frame_rgb24-&amp;gt;width = width;
    frame_rgb24-&amp;gt;height = height;
    frame_rgb24-&amp;gt;format = AV_PIX_FMT_RGB24;
    ret = av_frame_get_buffer(frame_rgb24, 0);
    if(ret &amp;lt; 0){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Error allocating the frame data ret = %d\n&amp;#34;, ret);
        return;
    }
    sws_scale(sws_ctx, (const uint8_t * const*)frame-&amp;gt;data, frame-&amp;gt;linesize, 0, frame-&amp;gt;height, frame_rgb24-&amp;gt;data, frame_rgb24-&amp;gt;linesize);
    printf(&amp;#34;image_size = %d width = %d height = %d &amp;#34;,image_size, width, height);
    BITMAPINFOHEADER infoheader;
    infoheader.biSize = sizeof(BITMAPINFOHEADER);
    infoheader.biWidth = width;
    infoheader.biHeight = height * (-1); // 高度坐标相反
    infoheader.biBitCount = 24;
    infoheader.biCompression = 0;
    infoheader.biSizeImage = 0;
    infoheader.biClrImportant = 0;
    infoheader.biClrUsed = 0;
    infoheader.biXPelsPerMeter = 0;
    infoheader.biYPelsPerMeter = 0;
    infoheader.biPlanes = 1;
    BITMAPFILEHEADER fileheader;
    fileheader.bfType = 0x4D42; // &amp;#34;BM&amp;#34;
    fileheader.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + image_size;
    fileheader.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
    fwrite(&amp;amp;fileheader, sizeof(BITMAPFILEHEADER), 1, f);
    fwrite(&amp;amp;infoheader, sizeof(BITMAPINFOHEADER), 1, f);
    fwrite(frame_rgb24-&amp;gt;data[0], 1, image_size, f);
    fclose(f);
    av_freep(&amp;amp;frame_rgb24-&amp;gt;data[0]);
    av_frame_free(frame_rgb24);
}

static void savePic(AVFrame *frame, char *filename){
    FILE *f = fopen(filename, &amp;#34;wb&amp;#34;);
    fprintf(f, &amp;#34;P5\n%d %d\n255\n&amp;#34;, frame-&amp;gt;width, frame-&amp;gt;height);
    // fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
    // size 每个元素的大小 nmemb 元素的个数  
    for (int i = 0; i &amp;lt; frame-&amp;gt;height; i++)
    {
        fwrite(frame-&amp;gt;data[0]+i*frame-&amp;gt;linesize[0], 1, frame-&amp;gt;width, f);
    }
    
    fclose(f);
}

static int decode(AVCodecContext *ctx, struct SwsContext *sws_ctx, AVFrame *frame, AVPacket *pkt, char *filename){
    int ret;
    char filename_filled[1024];
    ret = avcodec_send_packet(ctx, pkt);
    if(ret &amp;lt; 0){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Error sending a packet for decoding ret = %d %d\n&amp;#34;, ret,AVERROR(EINVAL));
        return ret;
    }

    while(ret &amp;gt;= 0){
        ret = avcodec_receive_frame(ctx, frame);
        if(ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){
            return 0;
        }else if(ret &amp;lt; 0){
            av_log(NULL, AV_LOG_ERROR, &amp;#34;Error during decoding\n&amp;#34;);
            return ret;
        }
        printf(&amp;#34;frame_number = %d\n&amp;#34;, ctx-&amp;gt;frame_number);
        snprintf(filename_filled, sizeof(filename)+5, &amp;#34;%s-%d.bmp&amp;#34;, filename, ctx-&amp;gt;frame_number);
        // savePic(frame, filename_filled);
        saveBmp(sws_ctx,frame,640, 360, filename_filled);
        fflush(stdout);
    }
    return 0;
}


int main(int argc, char *argv[]){
    // 1、处理一些参数
    // 2、打开文件
    // 3、从多媒体文件中找到音频流
    // 4、打开目的文件的上下文
    // 5、为目的文件打开音频流
    // 6、设置输出音频参数
    // 7、写多媒体文件头
    // 8、循环读取音频流，写入目的文件
    // 9、写文件尾
    // 10、 释放资源

    char* src;
    char* dst;
    AVCodecContext *ctx;
    AVFormatContext *fmt_ctx;
    AVStream *in_stream = NULL, *out_stream = NULL;
    const static AVCodec *codec;
    AVPacket *pkt;
    AVFrame *frame;
    struct SwsContext *sws_ctx = NULL;

    int index = -1;
    av_log_set_level(AV_LOG_DEBUG);
    if (argc &amp;lt; 3) {
        printf(&amp;#34;Usage: %s &amp;lt;input file&amp;gt; &amp;lt;output file&amp;gt;\n&amp;#34;, argv[0]);
        exit(1);
    }
    src = argv[1];
    dst = argv[2];
    fmt_ctx = avformat_alloc_context();
    // 第一个null 表示相关的格式 最后一个参数为选项 如果返回值为负值表示失败
    int ret = avformat_open_input(&amp;amp;fmt_ctx, src, NULL, NULL);
    if (ret &amp;lt; 0) {
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not open source file %s\n&amp;#34;, src);
        exit(1);
    }

    if ((ret = avformat_find_stream_info(fmt_ctx, NULL)) &amp;lt; 0) {
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Cannot find stream information\n&amp;#34;);
        return ret;
    }
    index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
    if(index &amp;lt; 0){
        // 第一参数可以指定为上下文
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not find %s stream in input file %s\n&amp;#34;, av_get_media_type_string(AVMEDIA_TYPE_VIDEO), src);
        goto _ERROR;
    }
    codec = avcodec_find_decoder(fmt_ctx-&amp;gt;streams[index]-&amp;gt;codecpar-&amp;gt;codec_id);
    if(codec == NULL){
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not find codec \n&amp;#34;);
        goto _ERROR;
    }
    ctx = avcodec_alloc_context3(NULL);
    if(ctx == NULL){
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not allocate codec context\n&amp;#34;);
        goto _ERROR;
    }
    // 重要 不要写avcodec_parameters_copy 否则会导致coredump
    avcodec_parameters_to_context(ctx, fmt_ctx-&amp;gt;streams[index]-&amp;gt;codecpar);
    // printf(&amp;#34;width %d height %d&amp;#34;, ctx-&amp;gt;width,ctx-&amp;gt;height);
    // 图像转换
    sws_ctx = sws_getContext(
                        ctx-&amp;gt;width, 
                        ctx-&amp;gt;height, 
                        AV_PIX_FMT_YUV420P, 
                        640, 
                        360, 
                        AV_PIX_FMT_BGR24,
                        SWS_BICUBIC, NULL, NULL, NULL);
    if (sws_ctx == NULL){
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not initialize the conversion context\n&amp;#34;);
        goto _ERROR;
    }
    // 将解码器和解码器上下文连接
    ret = avcodec_open2(ctx, codec, NULL);
    if(ret &amp;lt; 0){
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not open codec\n&amp;#34;);
        goto _ERROR;
    }
    frame = av_frame_alloc();
    if(frame == NULL){
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not allocate frame\n&amp;#34;);
        goto _ERROR;
    }
    pkt = av_packet_alloc();
    if(pkt == NULL){
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not allocate packet\n&amp;#34;);
        goto _ERROR;
    }
    int pkt_index = 0;
    while(av_read_frame(fmt_ctx, pkt) &amp;gt;= 0){
        if(pkt-&amp;gt;stream_index == index){
            // pkt_index ++;
            decode(ctx,sws_ctx,frame, pkt,dst);
            if(pkt_index ++ &amp;gt; 10)
                break;
            // av_packet_unref(pkt);
        }
    }
    decode(ctx,sws_ctx,frame, NULL,dst);

_ERROR:
    if(fmt_ctx != NULL){
        avformat_close_input(&amp;amp;fmt_ctx);
    }
    if(ctx) {
        avcodec_free_context(&amp;amp;ctx);
        ctx = NULL;
    }
    if(frame){
        av_frame_free(&amp;amp;frame);
        frame = NULL;
    }
    if(pkt){
        av_packet_free(&amp;amp;pkt);
        pkt = NULL;
    }
    if(sws_ctx){
        sws_freeContext(sws_ctx);
        sws_ctx = NULL;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>ffmpeg命令</title>
        <link>https://898311543.github.io/post/ffmpeg_command/</link>
        <pubDate>Wed, 16 Oct 2024 16:44:55 +0800</pubDate>
        
        <guid>https://898311543.github.io/post/ffmpeg_command/</guid>
        <description>&lt;h2 id=&#34;ffmpeg命令&#34;&gt;ffmpeg命令
&lt;/h2&gt;&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/1725547140054.png&#34; alt=&#39;1725547140054&#39; /&gt;
&lt;/p&gt;
&lt;h3 id=&#34;ffmpeg-处理音视频流程&#34;&gt;ffmpeg 处理音视频流程
&lt;/h3&gt;&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20240905224438715.png&#34; alt=&#39;image-20240905224438715&#39; /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;输入文件具有封装格式（将这个封装格式打开称之为解封装）-&amp;gt;解出来的格式也是编码之后的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码后的数据可以进行解码，解码之后得到解码后的数据帧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据帧encode之后可以得到编码数据包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码之后可以输出想要的格式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ffmpeg命令分类&#34;&gt;ffmpeg命令分类
&lt;/h2&gt;&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/1725549272444.png&#34; alt=&#39;1725549272444&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/1725549351267.png&#34; alt=&#39;1725549351267&#39; /&gt;
&lt;/p&gt;
&lt;h2 id=&#34;录制命令&#34;&gt;录制命令
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ffmpeg -list_devices true -f dshow -i dummy
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ffmpeg -f dshow -i video=&amp;#34;USB2.0 HD UVC WebCam&amp;#34; -vcodec libx264 -preset ultrafast desktop.mkv
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20240906224126914.png&#34; alt=&#39;image-20240906224126914&#39; /&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt; ffmpeg -i 东周列国：春秋篇.EP01.1996.DVDRip.x264.AC3-CMCT.mkv -vcodec copy -acodec copy a.mp4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ffmpeg -i 东周列国：春秋篇.EP01.1996.DVDRip.x264.AC3-CMCT.mkv -vn -acodec copy a.ac3&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;处理原始数据&#34;&gt;处理原始数据
&lt;/h2&gt;&lt;p&gt;生成原始数据：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ffmpeg -i 东周列国：春秋篇.EP01.1996.DVDRip.x264.AC3-CMCT.mkv -an -c:v rawvideo -pix_fmt yuv420p out.yuv
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于原始数据中不包含分辨率信息，需要手动指定：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ffplay -video_size 768x576  out.yuv
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ffmpeg提取pcm数据：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ffmpeg -i 东周列国：春秋篇.EP01.flv -vn -ar 44100 -ac 2 -f s16le out.pcm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为不含采样率、存储方式等信息所以无法直接播放，应使用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ffplay -ar 44100 -f s16le out.pcm
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;滤镜命令&#34;&gt;滤镜命令
&lt;/h2&gt;&lt;p&gt;使用滤镜要使用解码后的数据，压缩后的数据是无法处理的：&lt;/p&gt;
&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20240907151620144.png&#34; alt=&#39;image-20240907151620144&#39; /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;视频画面裁剪命令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt; ffmpeg -i 东周列国：春秋篇.EP01.flv -vf crop=in_w-400:in_h-200 -c:v libx264 -c:a copy out.mp4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ffmpeg -c:v h264_cuvid -crop 10x100x10x100 -i 东周列国：春秋篇.EP01.flv -c:v h264_nvenc -c:a copy out.mp4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;视频长度裁剪命令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ffmpeg -c:v h264_cuvid -crop 10x100x10x100 -i 东周列国：春秋篇.EP01.flv -ss 00:02:00 -t 10 -c:v h264_nvenc -c:a copy out.mp4 &lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ss指的是裁剪开始的时间 -t指的是视频持续的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ffmpeg音视频合并&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ffmpeg -f concat -i input.txt out.flv
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;input.txt内容为‘file filename’格式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;图片和视频互转&#34;&gt;图片和视频互转
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;视频转图片&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ffmpeg -i in.flv -r 1 -f image2 image-%3d.jpeg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图片转视频&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ffmpeg -i image-%3d.jpeg out.mp4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;直播推拉流&#34;&gt;直播推/拉流
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;直播推流
&lt;ul&gt;
&lt;li&gt;ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName
&lt;ul&gt;
&lt;li&gt;-re 减慢速度 以实际播放速度进行推流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;直播拉流
&lt;ul&gt;
&lt;li&gt;ffmpeg -i rtmp://server/live/streamName -c copy dump.flv&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ffmpeg-初级开发&#34;&gt;FFMPEG 初级开发
&lt;/h1&gt;&lt;h2 id=&#34;代码结构&#34;&gt;代码结构
&lt;/h2&gt;&lt;h3 id=&#34;日志系统&#34;&gt;日志系统
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;libavutil/log.h&amp;gt; //引入头文件
av_log_set_level(AV_LOG_DEBUG) //设置日志级别
av_log(NULL,AV_LOG_INFO,&amp;#34;...%s\n&amp;#34;,op)  //输入日志
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;日志级别：AV_LOG_ERROR、AV_LOG_WARNING、AV_LOG_INFO、AV_LOG_DEBUG&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;libavutil/log.h&amp;gt;

int main(int argc, char *argv[]){
    av_log_set_level(AV_LOG_ERROR);
    av_log(NULL, AV_LOG_INFO, &amp;#34;hello world\n&amp;#34;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;多媒体文件的基本概念&#34;&gt;多媒体文件的基本概念
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;多媒体文件其实是个容器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在容器中有很多流（Stream/Track）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个流是由不同的编码器编码的、&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流里抽出来的数据成为包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在一个包里包含着一个或多个帧&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;几个重要的结构体&#34;&gt;几个重要的结构体
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;AVFormatContext 容器&lt;/li&gt;
&lt;li&gt;AVStream 流或者轨&lt;/li&gt;
&lt;li&gt;AVPacket 包&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ffmpeg操作数据的基本步骤&#34;&gt;FFmpeg操作数据的基本步骤
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;解复用&lt;/li&gt;
&lt;li&gt;获取流&lt;/li&gt;
&lt;li&gt;读数据包&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;libavutil/log.h&amp;gt;
#include &amp;lt;libavutil/avutil.h&amp;gt;
#include &amp;lt;libavformat/avio.h&amp;gt;
#include &amp;lt;libavformat/avformat.h&amp;gt;

int main(int argc, char *argv[]){
    // 1、处理一些参数
    // 2、打开文件
    // 3、从多媒体文件中找到音频流
    // 4、打开目的文件的上下文
    // 5、为目的文件打开音频流
    // 6、设置输出音频参数
    // 7、写多媒体文件头
    // 8、循环读取音频流，写入目的文件
    // 9、写文件尾
    // 10、 释放资源

    char* src;
    char* dst;
    AVFormatContext *fmt_ctx, *ofmt_ctx;
    AVOutputFormat *outFmt;
    AVStream *in_stream = NULL, *out_stream = NULL;
    AVPacket pkt;
    int index = -1;
    av_log_set_level(AV_LOG_DEBUG);
    if (argc &amp;lt; 3) {
        printf(&amp;#34;Usage: %s &amp;lt;input file&amp;gt; &amp;lt;output file&amp;gt;\n&amp;#34;, argv[0]);
        exit(1);
    }
    src = argv[1];
    dst = argv[2];
    // 第一个null 表示相关的格式 最后一个参数为选项 如果返回值为负值表示失败
    int ret = avformat_open_input(&amp;amp;fmt_ctx, src, NULL, NULL);
    if (ret &amp;lt; 0) {
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not open source file %s\n&amp;#34;, src);
        exit(1);
    }
    index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0);
    if(index &amp;lt; 0){
        // 第一参数可以指定为上下文
        av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not find %s stream in input file %s\n&amp;#34;, av_get_media_type_string(AVMEDIA_TYPE_AUDIO), src);
        goto _ERROR;
    }
    ofmt_ctx = avformat_alloc_context();
    if(ofmt_ctx == NULL){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not allocate output context\n&amp;#34;);
        goto _ERROR;
    }
    outFmt = av_guess_format(NULL, dst, NULL);
    if(outFmt == NULL){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not find %s format\n&amp;#34;, dst);
        goto _ERROR;
    }
    ofmt_ctx-&amp;gt;oformat = outFmt;
    in_stream = fmt_ctx-&amp;gt;streams[index];
    out_stream = avformat_new_stream(ofmt_ctx, NULL);
    if(out_stream == NULL){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not allocate output stream\n&amp;#34;);
        goto _ERROR;
    }
    avcodec_parameters_copy(out_stream-&amp;gt;codecpar, in_stream-&amp;gt;codecpar);
    // 会根据输出文件类型设置编码器
    out_stream-&amp;gt;codecpar-&amp;gt;codec_tag = 0;
    ret = avio_open2(&amp;amp;ofmt_ctx-&amp;gt;pb, dst, AVIO_FLAG_WRITE, NULL, NULL);
    if(ret &amp;lt; 0){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not open output file %s\n&amp;#34;, dst);
        goto _ERROR;
    }
    ret = avformat_write_header(ofmt_ctx, NULL);
    if(ret &amp;lt; 0){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Error write header \n&amp;#34;);
        goto _ERROR;
    }
    while(av_read_frame(fmt_ctx, &amp;amp;pkt) &amp;gt;= 0){
        if(pkt.stream_index == index){
            pkt.stream_index = 0;
            pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&amp;gt;time_base, out_stream-&amp;gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);
            pkt.dts = pkt.dts;
            pkt.duration = av_rescale_q(pkt.duration, in_stream-&amp;gt;time_base, out_stream-&amp;gt;time_base);
            pkt.pos = -1;
            av_interleaved_write_frame(ofmt_ctx, &amp;amp;pkt);
            av_packet_unref(&amp;amp;pkt);
        }
    }
    av_write_trailer(ofmt_ctx); 

_ERROR:
    if(fmt_ctx != NULL){
        avformat_close_input(&amp;amp;fmt_ctx);
    }
    if(ofmt_ctx != NULL){
        avformat_free_context(ofmt_ctx);
    }
    if (ofmt_ctx-&amp;gt;pb)
    {
        avio_close(ofmt_ctx-&amp;gt;pb);
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20240911005025395.png&#34; alt=&#39;image-20240911005025395&#39; /&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;libavutil/log.h&amp;gt;
#include &amp;lt;libavutil/avutil.h&amp;gt;
#include &amp;lt;libavformat/avio.h&amp;gt;
#include &amp;lt;libavformat/avformat.h&amp;gt;

int main(int argc, char *argv[]){
    // 1、处理一些参数
    // 2、打开文件
    // 3、从多媒体文件中找到音频流
    // 4、打开目的文件的上下文
    // 5、为目的文件打开音频流
    // 6、设置输出音频参数
    // 7、写多媒体文件头
    // 8、循环读取音频流，写入目的文件
    // 9、写文件尾
    // 10、 释放资源

    char* src;
    char* dst;
    AVFormatContext *fmt_ctx=NULL, *ofmt_ctx=NULL;
    AVOutputFormat *outFmt;
    AVStream *in_stream = NULL, *out_stream = NULL;
    AVPacket pkt;
    int index = 0;
    int *stream_map = NULL;
    int i;
    av_log_set_level(AV_LOG_DEBUG);
    if (argc &amp;lt; 3) {
        printf(&amp;#34;Usage: %s &amp;lt;input file&amp;gt; &amp;lt;output file&amp;gt;\n&amp;#34;, argv[0]);
        exit(1);
    }
    src = argv[1];
    dst = argv[2];
    // 第一个null 表示相关的格式 最后一个参数为选项 如果返回值为负值表示失败
    int ret = avformat_open_input(&amp;amp;fmt_ctx, src, NULL, NULL);
    if (ret &amp;lt; 0) {
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not open source file %s\n&amp;#34;, src);
        exit(1);
    }
    // index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
    // if(index &amp;lt; 0){
    //     // 第一参数可以指定为上下文
    //     av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not find %s stream in input file %s\n&amp;#34;, av_get_media_type_string(AVMEDIA_TYPE_AUDIO), src);
    //     goto _ERROR;
    // }
    avformat_alloc_output_context2(&amp;amp;ofmt_ctx, NULL, NULL, dst);
    if(ofmt_ctx == NULL){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not allocate output context\n&amp;#34;);
        goto _ERROR;
    }
    stream_map= av_calloc(fmt_ctx-&amp;gt;nb_streams, sizeof(*stream_map)); 
    if(stream_map == NULL){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not allocate stream map\n&amp;#34;);
        goto _ERROR;
    }
    for(i = 0; i &amp;lt; fmt_ctx-&amp;gt;nb_streams; i++){
        stream_map[i] = i;
    }   
    for (i = 0; i &amp;lt; fmt_ctx-&amp;gt;nb_streams; i++){
        in_stream = fmt_ctx-&amp;gt;streams[i];
        AVCodecParameters *inCodecPar = in_stream-&amp;gt;codecpar;
        if(inCodecPar-&amp;gt;codec_type == AVMEDIA_TYPE_AUDIO ||
           inCodecPar-&amp;gt;codec_type == AVMEDIA_TYPE_VIDEO ||
           inCodecPar-&amp;gt;codec_type == AVMEDIA_TYPE_SUBTITLE
        ){
            stream_map[i] = index++;
        }
        else{
            stream_map[i] = -1;
            continue;
        }
        out_stream = avformat_new_stream(ofmt_ctx, NULL);
        if(out_stream == NULL){
            av_log(ofmt_ctx, AV_LOG_ERROR, &amp;#34;Could not allocate output stream\n&amp;#34;);
            goto _ERROR;
        }
        avcodec_parameters_copy(out_stream-&amp;gt;codecpar, in_stream-&amp;gt;codecpar);
        // 会根据输出文件类型设置编码器
        out_stream-&amp;gt;codecpar-&amp;gt;codec_tag = 0;
    }


    ret = avio_open2(&amp;amp;ofmt_ctx-&amp;gt;pb, dst, AVIO_FLAG_WRITE, NULL, NULL);
    if(ret &amp;lt; 0){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not open output file %s\n&amp;#34;, dst);
        goto _ERROR;
    }
    ret = avformat_write_header(ofmt_ctx, NULL);
    if(ret &amp;lt; 0){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Error write header \n&amp;#34;);
        goto _ERROR;
    }
    while(av_read_frame(fmt_ctx, &amp;amp;pkt) &amp;gt;= 0){
        // av_log(NULL, AV_LOG_INFO, &amp;#34;pkt index = %d\n&amp;#34;, pkt.stream_index);
        pkt.stream_index = stream_map[pkt.stream_index];
        if(pkt.stream_index &amp;lt; 0){
            av_packet_unref(&amp;amp;pkt);
            continue;
        }
        av_packet_rescale_ts(&amp;amp;pkt, fmt_ctx-&amp;gt;streams[pkt.stream_index]-&amp;gt;time_base, ofmt_ctx-&amp;gt;streams[pkt.stream_index]-&amp;gt;time_base);
        pkt.pos = -1;
        av_interleaved_write_frame(ofmt_ctx, &amp;amp;pkt);
        av_packet_unref(&amp;amp;pkt);
    }
    av_write_trailer(ofmt_ctx); 

_ERROR:
    if(fmt_ctx != NULL){
        avformat_close_input(&amp;amp;fmt_ctx);
    }
    if(ofmt_ctx != NULL){
        avformat_free_context(ofmt_ctx);
    }
    if (ofmt_ctx-&amp;gt;pb)
    {
        avio_close(ofmt_ctx-&amp;gt;pb);
    }
    if (stream_map)
    {
        av_freep(&amp;amp;stream_map);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;视频裁剪&#34;&gt;视频裁剪
&lt;/h3&gt;&lt;p&gt;





&lt;img class=&#34;img-fluid&#34; src=&#34;https://898311543.github.io/image-20240912002846369.png&#34; alt=&#39;image-20240912002846369&#39; /&gt;
&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;libavutil/log.h&amp;gt;
#include &amp;lt;libavutil/avutil.h&amp;gt;
#include &amp;lt;libavformat/avio.h&amp;gt;
#include &amp;lt;libavformat/avformat.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main(int argc, char *argv[]){
    // 1、处理一些参数
    // 2、打开文件
    // 3、从多媒体文件中找到音频流
    // 4、打开目的文件的上下文
    // 5、为目的文件打开音频流
    // 6、设置输出音频参数
    // 7、写多媒体文件头
    // 8、循环读取音频流，写入目的文件
    // 9、写文件尾
    // 10、 释放资源

    char* src;
    char* dst;
    AVFormatContext *fmt_ctx=NULL, *ofmt_ctx=NULL;
    AVOutputFormat *outFmt=NULL;
    AVStream *in_stream = NULL, *out_stream = NULL;
    AVPacket pkt;
    int index = 0;
    int *stream_map = NULL;
    int i;
    av_log_set_level(AV_LOG_DEBUG);
    if (argc &amp;lt; 5) {
        printf(&amp;#34;Usage: %s &amp;lt;input file&amp;gt; &amp;lt;output file&amp;gt;\n&amp;#34;, argv[0]);
        exit(1);
    }
    src = argv[1];
    dst = argv[2];
    int starttime = atoi(argv[3]);
    int endtime = atoi(argv[4]);
    // 第一个null 表示相关的格式 最后一个参数为选项 如果返回值为负值表示失败
    int ret = avformat_open_input(&amp;amp;fmt_ctx, src, NULL, NULL);
    if (ret &amp;lt; 0) {
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not open source file %s\n&amp;#34;, src);
        exit(1);
    }
    // index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
    // if(index &amp;lt; 0){
    //     // 第一参数可以指定为上下文
    //     av_log(fmt_ctx, AV_LOG_ERROR, &amp;#34;Could not find %s stream in input file %s\n&amp;#34;, av_get_media_type_string(AVMEDIA_TYPE_AUDIO), src);
    //     goto _ERROR;
    // }
    avformat_alloc_output_context2(&amp;amp;ofmt_ctx, NULL, NULL, dst);
    if(ofmt_ctx == NULL){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not allocate output context\n&amp;#34;);
        goto _ERROR;
    }
    stream_map= av_calloc(fmt_ctx-&amp;gt;nb_streams, sizeof(*stream_map)); 
    if(stream_map == NULL){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not allocate stream map\n&amp;#34;);
        goto _ERROR;
    }
    for(i = 0; i &amp;lt; fmt_ctx-&amp;gt;nb_streams; i++){
        stream_map[i] = i;
    }   
    for (i = 0; i &amp;lt; fmt_ctx-&amp;gt;nb_streams; i++){
        in_stream = fmt_ctx-&amp;gt;streams[i];
        AVCodecParameters *inCodecPar = in_stream-&amp;gt;codecpar;
        if(inCodecPar-&amp;gt;codec_type == AVMEDIA_TYPE_AUDIO ||
           inCodecPar-&amp;gt;codec_type == AVMEDIA_TYPE_VIDEO ||
           inCodecPar-&amp;gt;codec_type == AVMEDIA_TYPE_SUBTITLE
        ){
            stream_map[i] = index++;
        }
        else{
            stream_map[i] = -1;
            continue;
        }
        out_stream = avformat_new_stream(ofmt_ctx, NULL);
        if(out_stream == NULL){
            av_log(ofmt_ctx, AV_LOG_ERROR, &amp;#34;Could not allocate output stream\n&amp;#34;);
            goto _ERROR;
        }
        avcodec_parameters_copy(out_stream-&amp;gt;codecpar, in_stream-&amp;gt;codecpar);
        // 会根据输出文件类型设置编码器
        out_stream-&amp;gt;codecpar-&amp;gt;codec_tag = 0;
    }

    ret = avio_open2(&amp;amp;ofmt_ctx-&amp;gt;pb, dst, AVIO_FLAG_WRITE, NULL, NULL);
    if(ret &amp;lt; 0){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Could not open output file %s\n&amp;#34;, dst);
        goto _ERROR;
    }
    ret = avformat_write_header(ofmt_ctx, NULL);
    if(ret &amp;lt; 0){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Error write header \n&amp;#34;);
        goto _ERROR;
    }
    int64_t *dst_start_time_pts = av_calloc(ofmt_ctx-&amp;gt;nb_streams, sizeof(int64_t));
    int64_t *dst_start_time_dts = av_calloc(ofmt_ctx-&amp;gt;nb_streams, sizeof(int64_t));
    for(i = 0; i &amp;lt; fmt_ctx-&amp;gt;nb_streams; i++){
        dst_start_time_pts[i] = -1;
        dst_start_time_dts[i] = -1;
    }

    ret = av_seek_frame(fmt_ctx, -1, starttime * AV_TIME_BASE, AVSEEK_FLAG_BACKWARD);
    if(ret &amp;lt; 0){
        av_log(NULL, AV_LOG_ERROR, &amp;#34;Error seek frame \n&amp;#34;);
        goto _ERROR;
    }
    while(av_read_frame(fmt_ctx, &amp;amp;pkt) &amp;gt;= 0){
        if(av_q2d(fmt_ctx-&amp;gt;streams[pkt.stream_index]-&amp;gt;time_base) * pkt.pts &amp;gt; endtime ){
            av_packet_unref(&amp;amp;pkt);
            break;
        }
        pkt.stream_index = stream_map[pkt.stream_index];
        if(dst_start_time_pts[pkt.stream_index] == -1 &amp;amp;&amp;amp; pkt.pts &amp;gt; 0){
            dst_start_time_pts[pkt.stream_index] = pkt.pts;
        }
        if(dst_start_time_dts[pkt.stream_index] == -1 &amp;amp;&amp;amp; pkt.dts &amp;gt; 0){
            dst_start_time_dts[pkt.stream_index] = pkt.dts;
        }
        pkt.pts = pkt.pts - dst_start_time_pts[pkt.stream_index];
        pkt.dts = pkt.dts - dst_start_time_dts[pkt.stream_index];
        if (pkt.pts &amp;lt; pkt.dts) {
            pkt.pts = pkt.dts;
        }
        av_log(NULL, AV_LOG_DEBUG, &amp;#34;pkt.pts = %lld, pkt.dts = %lld, pkt.stream_index = %d\n&amp;#34;, pkt.pts, pkt.dts, pkt.stream_index);

        if(pkt.stream_index &amp;lt; 0){
            av_packet_unref(&amp;amp;pkt);
            continue;
        }
        av_packet_rescale_ts(&amp;amp;pkt, fmt_ctx-&amp;gt;streams[pkt.stream_index]-&amp;gt;time_base, ofmt_ctx-&amp;gt;streams[pkt.stream_index]-&amp;gt;time_base);
        pkt.pos = -1;
        av_interleaved_write_frame(ofmt_ctx, &amp;amp;pkt);
        av_packet_unref(&amp;amp;pkt);
    }
    av_write_trailer(ofmt_ctx); 

_ERROR:
    if(fmt_ctx != NULL){
        avformat_close_input(&amp;amp;fmt_ctx);
    }
    if(ofmt_ctx != NULL){
        avformat_free_context(ofmt_ctx);
    }
    if (ofmt_ctx-&amp;gt;pb)
    {
        avio_close(ofmt_ctx-&amp;gt;pb);
    }
    if (stream_map)
    {
        av_freep(&amp;amp;stream_map);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        
    </channel>
</rss>
